---
title: Verifying Presentations
sidebar:
  label: Verifying Presentations
  order: 4
---

Verifiers validate two things:

1. The issuer-signed JWT is authentic and trusted.
2. Every disclosure presented matches one of the `_sd` digests in the payload (including nested structures).

## Basic verification flow

The snippet below assumes you obtained `$presentation` from the holder chapter.

```php
use Nyra\SdJwt\Verification\SdJwtVerifier;
use Nyra\SdJwt\Jwt\FirebaseJwtVerifier;
use Nyra\SdJwt\Verification\VerifierOptions;
use Firebase\JWT\Key;

$jwtVerifier = new FirebaseJwtVerifier(new Key('issuer-secret', 'HS256'));
$verifier = new SdJwtVerifier($jwtVerifier);

$result = $verifier->verify($presentation->toCompact(), new VerifierOptions());

echo 'Verified issuer: ' . $result->payload()['iss'] . PHP_EOL;
```

The payload you receive is the fully reconstructed claim set *without* any `_sd` scaffolding or `_sd_alg` claim.

## Enforcing key binding

When key binding is required, pass a `VerifierOptions` instance that spells out the policies a verifier cares about. You can provide a public key manually or rely on the credentialâ€™s `cnf.jwk` claim.

The next example expects a `$presentationWithKb` generated in the key binding chapter.

```php
use Nyra\SdJwt\Support\JwkConverter;

$holderPublicJwk = [
    'kty' => 'EC',
    'crv' => 'P-256',
    'x'   => 'TCAER19Zvu3OHF4j4W4vfSVoHIP1ILilDls7vCeGemc',
    'y'   => 'ZxjiWWbZMQGHVWKVQ4hbSIirsVfuecCE6t4jT9F2HZQ',
];

$options = new VerifierOptions(
    requireKeyBinding: true,
    expectedAudience: 'https://verifier.example',
    expectedNonce: 'nonce-123',
    currentTime: time(),
    keyBindingKey: JwkConverter::toKey($holderPublicJwk, 'ES256'),
);

$verified = $verifier->verify($presentationWithKb->toCompact(), $options);
```

If you set `keyBindingKey` to `null`, the verifier automatically converts the `cnf.jwk` value using `JwkConverter`.

### Validation checklist

`SdJwtVerifier` applies the draft requirements:

- Signature algorithm is allowed and not `none`.
- Each disclosure is parsed, hashed, and matched to a digest.
- No duplicate digests or forbidden claim names (`_sd`, `...`).
- `_sd_alg` appears only at the top level.
- When key binding is required: kb+jwt header `typ="kb+jwt"`, acceptable `iat`, matching `aud` and `nonce`, and correct `sd_hash` derived from the presented SD-JWT string.

Any violation raises a descriptive exception under `Nyra\SdJwt\Exception`.

## Inspecting disclosures that were used

```php
foreach ($verified->disclosures() as $encoded) {
    echo "Received disclosure: {$encoded}" . PHP_EOL;
}
```

This powers audit logging, demonstrates which claims were released, and can be fed into consent records.

Continue to the next chapter to explore kb+jwt payloads and `sd_hash` in more depth.

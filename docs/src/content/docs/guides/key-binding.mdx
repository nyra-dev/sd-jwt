---
title: Key Binding & sd_hash
sidebar:
  label: Key Binding & sd_hash
  order: 5
---

Key binding ensures that the entity presenting a credential controls the private key referenced in the SD-JWT. This chapter focuses on how the library implements Section 4.3 of the draft and the verification steps in Section 7.3.

## Holder side recap

When the holder calls `buildPresentation()` with `KeyBindingOptions`, the library:

1. Serialises the presentation (`issuer JWT` + disclosures + trailing `~`).
2. Hashes that string using the issuer’s `_sd_alg`.
3. Signs a kb+jwt containing `iat`, `aud`, `nonce`, and `sd_hash` using the provided signer.

```php
use Nyra\SdJwt\Holder\KeyBindingOptions;
use Nyra\SdJwt\Jwt\FirebaseJwtSigner;

$options = new KeyBindingOptions(
    audience: 'https://verifier.example',
    nonce: bin2hex(random_bytes(8)),
    issuedAt: time(),
);

$holderPrivateKey = file_get_contents(__DIR__ . '/keys/holder-private.pem');

$presentation = $holder->buildPresentation(
    paths: ['family_name'],
    keyBindingOptions: $options,
    keyBindingSigner: new FirebaseJwtSigner($holderPrivateKey, 'ES256')
);
```

The resulting presentation compact string ends with the kb+jwt instead of a trailing tilde.

## Verifier checklist

`SdJwtVerifier` validates the kb+jwt with the following rules:

- Header `typ` must be `kb+jwt` and `alg` must not be `none`.
- The signature is verified using the supplied key or the `cnf.jwk` claim.
- `iat` must be within the sliding window defined by `VerifierOptions`.
- `aud` and `nonce` must match expectations.
- `sd_hash` must equal the hash of `issuer~disclosures~` using the same algorithm as `_sd_alg`.

Any mismatch results in an `InvalidKeyBinding` or `KeyBindingVerificationFailed` exception.

## Supported key types

`JwkConverter` understands the most common JWK formats:

| kty | Example usage |
| --- | ------------- |
| `oct` | Symmetric HS256 or HS512 keys shared between issuer and verifier |
| `RSA` | Standard RS256/RS384 public keys |
| `EC` | P-256, P-384, P-521, and secp256k1 curves |

For EC keys, coordinate lengths are validated to prevent truncated or padded keys from slipping through.

## Debugging tips

- Log the `sd_hash` value on both holder and verifier to confirm the same base string is hashed.
- When kb+jwt validation fails, inspect `VerifiedSdJwt::keyBindingHeaders()` and `VerifiedSdJwt::keyBindingPayload()` to see the parsed values.
- Ensure your verifier clock is in sync; the default leeway accepts skew of ±60 seconds in the future and 5 minutes in the past (configurable via `VerifierOptions`).

Proceed to the final chapter for an end-to-end script that ties everything together.
